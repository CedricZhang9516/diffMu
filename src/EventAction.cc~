//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......
//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......

#include "EventAction.hh"

#include "DetectorConstruction.hh"
#include "RunAction.hh"
#include "HistoManager.hh"

#include "G4Event.hh"
#include "G4SystemOfUnits.hh"

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......

EventAction::EventAction(HistoManager* histo)
  :fHistoManager(histo)
{  
  fPrintModulo = 100;
}

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......

EventAction::~EventAction()
{ }

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......

void EventAction::BeginOfEventAction(const G4Event* evt)
{  
  runNumber = fHistoManager->GetRunNumber();
  evtNb = evt->GetEventID();
  fHistoManager->SetEventNumber(evtNb);
  ResetEvent();
  if (evtNb%fPrintModulo == 0) 
    G4cout << "\n---> Begin of event: " << evtNb << G4endl;
  
  //  This doesn't seem to work...
  //  memset(nhits, 0, sizeof(nhits[0]*nscints));
  //  memset(tdc, -1.0*CLHEP::nanosecond, sizeof(tdc[0][0]*nscints*MAX_NHITS));
  //  memset(edep, -1.0*CLHEP::keV, sizeof(edep[0][0]*nscints*MAX_NHITS));

}

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......

void EventAction::EndOfEventAction(const G4Event*)
{
  //fill histograms
  //
  fHistoManager->FillHisto(0, xInit/CLHEP::mm);
  fHistoManager->FillHisto(1, yInit/CLHEP::mm);
  fHistoManager->FillHisto(2, zInit/CLHEP::mm);
  
  if (tmuonDecay > 0.) {
    fHistoManager->FillHisto(3, xmuonDecay/CLHEP::mm);
    fHistoManager->FillHisto(4, ymuonDecay/CLHEP::mm);
    fHistoManager->FillHisto(5, zmuonDecay/CLHEP::mm);
    fHistoManager->FillHisto(6, tmuonDecay/CLHEP::microsecond);
    if (dxPosi > 0.) {
      fHistoManager->FillHisto(7, tmuonDecay/CLHEP::microsecond);
    }
    else if (dxPosi < 0.) {
      fHistoManager->FillHisto(8, tmuonDecay/CLHEP::microsecond);
    }	  
  }

  //if (tMuDecay > 0.)   // wrong condition if Mu loses electron and decays as muon
  if ( !fNewMuInit) {             // Mu was formed
    fHistoManager->FillHisto(9, xMuInit/CLHEP::mm);
    fHistoManager->FillHisto(10, yMuInit/CLHEP::mm);
    fHistoManager->FillHisto(11, zMuInit/CLHEP::mm);
    fHistoManager->FillHisto(12, dxMuInit);
    fHistoManager->FillHisto(13, dyMuInit);
    fHistoManager->FillHisto(14, dzMuInit);
    fHistoManager->FillHisto(15, std::log10(ekMuInit/CLHEP::eV));
    fHistoManager->FillHisto(16, tMuInit/CLHEP::microsecond);
    if ( !fNewMuEmit ) {          // Mu was emitted 
      fHistoManager->FillHisto(17, xMuEmit/CLHEP::mm);
      fHistoManager->FillHisto(18, yMuEmit/CLHEP::mm);
      fHistoManager->FillHisto(19, zMuEmit/CLHEP::mm);
      fHistoManager->FillHisto(20, dxMuEmit);
      fHistoManager->FillHisto(21, dyMuEmit);
      fHistoManager->FillHisto(22, dzMuEmit);
      fHistoManager->FillHisto(23, std::log10(ekMuEmit/CLHEP::eV));
      fHistoManager->FillHisto(24, tMuEmit/CLHEP::microsecond);	  
    }
    fHistoManager->FillHisto(25, xMuDecay/CLHEP::mm);
    fHistoManager->FillHisto(26, yMuDecay/CLHEP::mm);
    fHistoManager->FillHisto(27, zMuDecay/CLHEP::mm);
    fHistoManager->FillHisto(28, rMuDecay/CLHEP::mm);
    fHistoManager->FillHisto(29, tMuDecay/CLHEP::microsecond);
    if ( !fNewMuEmit ) {          // Mu was emitted
      fHistoManager->FillHisto(30, zMuDecay/CLHEP::mm);	
      fHistoManager->FillHisto(31, tMuDecay/CLHEP::microsecond);
    }
    if (dxPosi > 0.) {
      fHistoManager->FillHisto(32, tMuDecay/CLHEP::microsecond);
    }
    else if (dxPosi < 0.) {
      fHistoManager->FillHisto(33, tMuDecay/CLHEP::microsecond);
    }
  }

  //    fHistoManager->FillNtuple1(sumedep,wtavg,nscints);

  //  for (G4int iposi = 0; iposi < nscints; iposi++)
  //    {
  //      if (feScintInc[iposi])
  //	{
  //	  fHistoManager->FillHisto(7 + iposi, tHit[iposi]/CLHEP::microsecond);
  //	}
  //    }

  fHistoManager->Fill2DHisto(0, xInit/CLHEP::mm, yInit/CLHEP::mm);
  if (tmuonDecay > 0.) {
    fHistoManager->Fill2DHisto(1, zmuonDecay/CLHEP::mm, ymuonDecay/CLHEP::mm);
  }
  if (tMuDecay > 0.) {
    fHistoManager->Fill2DHisto(1, zMuDecay/CLHEP::mm, yMuDecay/CLHEP::mm);   // filled with muon and Mu
    fHistoManager->Fill2DHisto(2, xMuDecay/CLHEP::mm, yMuDecay/CLHEP::mm);
    fHistoManager->Fill2DHisto(3, zMuDecay/CLHEP::mm, yMuDecay/CLHEP::mm);
    fHistoManager->Fill2DHisto(4, zMuDecay/CLHEP::mm, tMuDecay/CLHEP::microsecond);
    tMuLRDis = std::min(tMuLROut,tMuDecay);
  }
  else {
    tMuLRDis = tMuLROut;
  }
  if (fTargetStop) {
    fHistoManager->Fill2DHisto(5, tTgtStop/CLHEP::microsecond, zTgtStop/CLHEP::mm);
  }
  // 2D hists 5,6 is filled in SteppingAction
  if ( (tMuLRIn < 20.*CLHEP::microsecond) && (tMuLRDis < 20.*CLHEP::microsecond) ) {
    fHistoManager->Fill2DHisto(6, tMuLRIn/CLHEP::microsecond, tMuLRDis/CLHEP::microsecond);
  }  
  
  //fill ntuple(s)
  //
  //  fHistoManager->FillNtuple1(runNumber,evtNb,xInit/CLHEP::mm,yInit/CLHEP::mm,zInit/CLHEP::mm,
  //			     xmuDecay/CLHEP::mm,ymuDecay/CLHEP::mm,zmuDecay/CLHEP::cm,tmuDecay/CLHEP::microsecond,
  //			     nhits,tdc,edep,nscints);
}  

void EventAction::SetIfNewEvent(G4bool lval)
{  //set flag to identify a new event for step evaluation
  fNewEvent = lval;
}

void EventAction::SetIfTargetStop(G4bool lval)
{  //set flag to identify muons stopping (E<Elow) in target volume
  fTargetStop = lval;
}

void EventAction::SetIfNewMuInit(G4bool lval)
{  //set flag to identify a new event for step evaluation
  fNewMuInit = lval;
}

void EventAction::SetIfNewMuEmit(G4bool lval)
{  //set flag to identify the first emission of Mu from aerogel to vacuum
  fNewMuEmit = lval;
}

void EventAction::ResetEvent()
{
  tmuonDecay = -1.*CLHEP::nanosecond;
  tMuLRIn = DBL_MAX;
  tMuLROut = DBL_MAX;
  tMuDecay = -1.*CLHEP::nanosecond;
  tPosi = -1.*CLHEP::nanosecond;
  fNewEvent = true;  // new event, flag for actions taken only once at beginning of event
  fTargetStop = false;
  fNewMuInit = true;   // new Mu created, flag for actions at initial Mu creation
  fNewMuEmit = true;   // initial Mu emission, flag for actions at initial Mu emission
}

void EventAction::Fill1D(G4int ihist, G4double xbin)
{
  fHistoManager->FillHisto(ihist, xbin);
}

void EventAction::Fill2D(G4int ihist, G4double xbin, G4double ybin)
{
  fHistoManager->Fill2DHisto(ihist, xbin, ybin);
}

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......
